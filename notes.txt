RESTFUL SERVER / API
==============

1. What is a RESTful API?
========================
REresentational State Transfter
Transfer data around
Client -> Server relationship - MVC Paradigm 

Examples:
Client (Mobile App)
Access to third-party
Send data, and get data so it can be used in our code
Client (browser/SPA)

STATELESS BACKENDS, don't care about individual client which connects to them.

SEND A REQUEST, HANDLE A RESPONSE
Server with url's supported by the server by endpoints -> send AJAX (async http request)
ie.             /users              /posts          /products
HTTP VERBS:  GET|POST|DELETE      GET|POST|PATCH        GET

AJAX allows us to get information back without refreshing a page

Data exchanged in json data, sometimes URLEncoded, FormData

RESTful Constraints
1. Client-Server Architecture
-> Separation of concerns: RESTful API should not care about UI

2. Stateless 
-> No client context (e.g. session) is stored on server

3. Cacheability
->Responses must define themselves as cacheable or non-cacheable

4. Layered System
-> Intermediate servers maybe used without the Client knowing it (in between server, behind the scenes)

5. Uniform Interface
-> Resources are indentified in REquests, transferred data is decoupled from db schema. Can deviate from 
schema.  Self-descriptive messages links to further resources.

6. Code on Demnad (Optional)
-> Executable code could be transferred. Gives client some executable code.

2. Planning and First Steps
=====================

/products   /products/{id}
GET | POST  GET | PATCH | DELETE

/orders       /orders/{id}
GET | POST      GET | DELETE


Express
app.use() sets up middleware 
app.use((req, res, next) => {
  res.status(200).json({
**SENDS STATUS CODE
  json stringed data
  })
  
});

5. Handle parsing request body and handling CORS 
body-parser
app.use(bodyParser.urlencoded({extended}))
true -> handles extended bodies with rich data
false -> handles simple, short bodies

app.use(bodyParser.json) -> encodes to json data making it easily readable

CORS ERRORS!
No 'Access-COntrol-Allow-Origin' header is present on the requested resource. 

Cross Origin Resource Sharing -> security feature
Clent -> Server if both client and server coming from the same place. Trying to Access
resources on your server that exist where client is.  Therefore, when trying to make requests 
where server and client are in other locations is standard case.  Client and server have different
origins.  

Tells the client to allow access to server.  Send correct headers to mitigate CORS 

app.use((res, req, next) => {
  res.header('Access=Control-Allow-Origin', '*');
  res.header(
    'Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization'
    );
    // Browser always sends an options request first when sending a POST or PUT REQ
    // Unavoidable. Browser checks if you can 
    if (req.method === 'OPTIONS') {
      res.header('Access-Control-Allow-Methods', 'PUT, POST, PATCH, DELETE, GET');
      return res.status(200).json({})
    }
});

Why can POSTMAN access api without CORS issues?
COrs are a browser security feature
Postman just a testing tool
Cors restrictions based on ensuring other web pages can't access your api


6. MondoDB and Mongoose
